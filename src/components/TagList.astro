---
import { getAllTags } from '@/services/BlogService';
import type { BlogTag } from '@/services/BlogService';
import { UI_TEXT, URLS } from '@/consts';

const tags = await getAllTags();
const hasTags = tags.length > 0;
const searchInputId = 'tag-search';
---

<div class="flex flex-col gap-3" data-tag-list-root>
  <h2 class="text-xl font-bold">{UI_TEXT.tagsTitle}</h2>
  {hasTags ? (
    <>
      <label class="sr-only" for={searchInputId}>{UI_TEXT.tagSearchLabel}</label>
      <input
        id={searchInputId}
        type="search"
        class="w-full rounded-md border border-gray-600 bg-black/20 px-3 py-2 text-sm transition-colors focus:border-gray-400 focus:outline-none focus:ring-2 focus:ring-gray-500"
        placeholder={UI_TEXT.tagSearchPlaceholder}
        data-tag-search
        inputmode="search"
        autocomplete="off"
        enterkeyhint="search"
      />
      <div class="flex flex-wrap gap-x-2 gap-y-0.5" data-tag-container>
        {tags.map((tag: BlogTag) => (
          <a
            href={`${URLS.tags}/${tag.slug}/`}
            class="block px-2 py-1 rounded-md transition-colors"
            aria-label={`查看关于 ${tag.name} 标签的文章`}
            data-tag-item
            data-tag-name={tag.name}
            data-tag-slug={tag.slug}
          >
            {tag.name} <span class="opacity-70">({tag.count})</span>
          </a>
        ))}
      </div>
      <p class="text-sm text-gray-500 hidden" data-tag-empty>{UI_TEXT.tagSearchNoResults}</p>
    </>
  ) : (
    <p class="text-gray-400">{UI_TEXT.noTags}</p>
  )}
</div>

{hasTags && (
  <script is:inline>
    (() => {
      const init = () => {
        document.querySelectorAll('[data-tag-list-root]').forEach((root) => {
          if (!root || root.dataset.tagSearchInitialized === 'true') {
            return;
          }

          const searchInput = root.querySelector('[data-tag-search]');
          const emptyState = root.querySelector('[data-tag-empty]');
          const tagItems = Array.from(root.querySelectorAll('[data-tag-item]'));

          if (!searchInput || tagItems.length === 0) {
            return;
          }

          root.dataset.tagSearchInitialized = 'true';

          const entries = tagItems.map((element) => ({
            element,
            keywords: `${(element.dataset.tagName || '').toLowerCase()} ${(element.dataset.tagSlug || '').toLowerCase()}`.trim(),
          }));

          const applyFilter = (value) => {
            const query = value.trim().toLowerCase();
            let visibleCount = 0;

            entries.forEach(({ element, keywords }) => {
              const matches = query === '' || keywords.includes(query);
              element.classList.toggle('hidden', !matches);
              if (matches) {
                visibleCount += 1;
              }
            });

            if (emptyState) {
              emptyState.classList.toggle('hidden', visibleCount !== 0);
            }
          };

          searchInput.addEventListener('input', (event) => {
            const target = event.target;
            if (target instanceof HTMLInputElement) {
              applyFilter(target.value);
            }
          });

          applyFilter(searchInput.value || '');
        });
      };

      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', init, { once: true });
      } else {
        init();
      }

      document.addEventListener('astro:page-load', init);
      document.addEventListener('astro:after-swap', init);
    })();
  </script>
)}
