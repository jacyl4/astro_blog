---
tags:
  - "#database"
  - "#database-architecture"
created: 2025-08-07
---
# 现代数据平台架构：关系型、内存型与分布式数据库解决方案综合分析

## 第一部分：精通 MySQL + Redis 架构

对于处理复杂元数据和查询场景的现代应用而言，`MySQL` + `Redis` 的组合已成为一种经过实战检验的行业标准。然而，要充分发挥其潜力，并确保系统的可维护性和数据一致性，需要对底层模式、一致性模型及现代部署策略有深刻的理解。本部分旨在深入剖析这一传统架构，从基础的缓存模式到先进的云原生部署方案，为技术决策者提供一个坚实的基准。

### 1.1 基础缓存模式与一致性模型

将 `Redis` 作为 `MySQL` 的缓存层引入架构时，首要挑战便是如何维护两个独立系统之间的数据同步。不同的缓存策略在性能、复杂性和一致性保证之间做出了不同的权衡。

#### 深入分析缓存策略

应用程序与数据库和缓存的交互方式，定义了不同的缓存模式。理解这些模式是优化 `MySQL` + `Redis` 架构的第一步。

* **旁路缓存 (Cache-Aside / Lazy Loading)**
    这是最广泛应用的模式。其核心逻辑由应用程序代码负责管理 [^1]。
  * **读操作**：应用程序首先尝试从 `Redis` 读取数据。如果缓存命中（Cache Hit），则直接返回数据。如果缓存未命中（Cache Miss），应用程序会查询 `MySQL`，获取数据后，先将其写入 `Redis` 缓存，然后再返回给客户端 [^3]。
  * **写操作**：应用程序直接更新 `MySQL` 中的数据，然后**使缓存中的对应条目失效**（通常是删除操作，而非更新）[^2]。删除操作比更新更简单高效，因为它避免了处理复杂对象的序列化和反序列化，并将新数据的加载推迟到下一次缓存未命中时，确保了缓存中的数据总是从数据库的最新状态加载而来。

    该模式的主要优势在于，只有被实际请求的数据才会被缓存，避免了缓存资源的浪费。

* **读穿 (Read-Through)**
    在这种模式下，应用程序的逻辑被简化，它只与缓存层交互 [^1]。当缓存未命中时，由缓存服务自身负责从后端数据库（`MySQL`）加载数据，并返回给应用程序 [^3]。这对于应用开发者来说是透明的。值得注意的是，`Redis` 本身并不原生支持此模式，但可以通过 `Redis Gears` 这样的模块化工具或封装了该逻辑的库和框架来实现 [^3]。

* **写穿 (Write-Through)**
    为保证数据的高度一致性，可以采用写穿模式。应用程序将数据直接写入缓存，缓存层则负责同步地将数据写入后端数据库 [^3]。只有当缓存和数据库都成功写入后，操作才算完成。这种模式以牺牲一定的写延迟为代价，换取了缓存和数据库之间的强一致性，适用于对数据新鲜度要求极高的场景 [^5]。

* **后写 (Write-Behind / Write-Back)**
    后写模式与写穿类似，但缓存层对数据库的写入是异步的 [^3]。应用程序将数据写入缓存后即可立即返回，由缓存服务在稍后的时间点将数据批量或异步地写入数据库。这种模式为应用程序提供了极低的写延迟，但代价是增加了数据丢失的风险——如果在数据被持久化到数据库之前缓存节点发生故障，这部分数据将会丢失。

* **预热/提前刷新 (Refresh-Ahead)**
    这是一种主动的缓存策略。系统可以预测哪些数据可能会被频繁访问，并在其缓存过期之前就主动从数据库重新加载，以更新缓存内容 [^3]。这种模式可以有效减少因缓存过期而导致的用户访问延迟，确保热点数据始终具有较低的响应时间。

#### 核心挑战：数据一致性与竞态条件

在 `MySQL` + `Redis` 架构中，数据一致性问题是其固有的阿喀琉斯之踵。问题的根源在于，应用程序被迫在一个缺乏原生事务协调机制的环境下，扮演一个跨越两个独立系统（数据库和缓存）的分布式事务协调者的角色。由于数据库的写操作和缓存的失效操作并非原子性的，并发场景下的执行时序问题会导致各种竞态条件，从而破坏数据一致性。
最常见的“先更新数据库，再删除缓存”策略虽然是业界公认的最佳实践，但它并不能完全避免数据不一致的问题。以下是两种典型的竞态条件场景 [^2]：

1. **读写并发导致的数据不一致**
    这是一个在正常情况下也可能发生的场景，尽管概率较低。
    * **场景**：线程 A 发起一个读请求，缓存未命中。于是线程 A 从数据库读取了旧值（例如 v1）。
    * **并发**：在线程 A 将旧值 v1 写入缓存之前，线程 B 发起了一个写请求，成功将数据库中的值更新为 v2，并删除了缓存。
    * **问题**：线程 A 继续执行，将它之前读取到的旧值 v1 写入了缓存。
    * **后果**：缓存中存储了脏数据（v1），而数据库中的数据是新值（v2）。后续所有读请求都将从缓存中读到过时的数据，直到缓存过期或下一次写操作发生。

2. **写操作过程中的异常**
    在极端情况下，系统故障可能导致持久的数据不一致。
    * **场景**：线程 A 成功更新了数据库。
    * **故障**：在执行删除缓存的操作之前，应用程序或服务器发生崩溃。
    * **后果**：缓存中的旧数据永远不会被删除（除非设置了过期时间），导致所有后续的读请求都将命中缓存并获取到过时的值，造成了持久性的数据不一致 [^1]。

相较之下，其他更新策略（如“先删除缓存，再更新数据库”或“先更新数据库，再更新缓存”）会引入概率更高的不一致风险，因此不被推荐 [^2]。例如，“先删缓存再更新数据库”的策略，如果在删除缓存后、更新数据库前，有另一个读请求进来，它会发现缓存未命中，从而将旧的数据库值读出并重新写入缓存，导致脏数据问题。

#### 先进的一致性解决方案

为了缓解上述问题，业界发展出了一些更可靠的解决方案。

* **延迟双删 (Double-Delete Pattern)**
    这是一种针对上述竞态条件的补偿机制 [^2]。
    1. 先删除缓存。
    2. 再更新数据库。
    3. 短暂休眠（例如几百毫秒）。
    4. 再次删除缓存。
        其逻辑在于，短暂的休眠窗口是为了让步骤2之后可能发生的、导致脏数据回写缓存的读操作完成。随后的第二次删除操作，则可以确保这个脏数据被清理掉。这种模式虽然在理论上仍存在极端情况下的失败可能（例如休眠时间不足），但在实践中已能将不一致的概率降至极低。

* **基于 Binlog 的复制 (Change Data Capture - CDC)**
    这是目前解决 `MySQL` + `Redis` 一致性问题的最可靠和优雅的方案。它将缓存同步逻辑从业务应用中解耦出来，通过订阅和解析 `MySQL` 的二进制日志（binlog）来实现 [^2]。
  * **架构**：部署一个独立的 CDC 工具（如 `Debezium` 或阿里巴巴开源的 `Canal` [^2]），该工具伪装成一个 `MySQL` 的从库，实时订阅主库的 `binlog`。
    * **流程**：当数据库发生任何数据变更（`INSERT`, `UPDATE`, `DELETE`）时，这些变更事件会被 `binlog` 记录下来。CDC 工具捕获这些事件，将其解析为结构化的消息，然后通过消息队列（如 `Kafka`）分发出去，或者直接调用 `Redis` API 来更新或失效相应的缓存。
    * **优势**：这种架构将数据同步的责任从应用层转移到了基础设施层，应用代码不再需要关心缓存的维护，从而大大简化了业务逻辑。由于 `binlog` 是数据库事务性的、有序的记录，这种方式保证了数据同步的可靠性和最终一致性。此外，这种架构也为更复杂的场景（如数据同步到 `Elasticsearch`）奠定了基础。

### 1.2 现代部署与维护架构

除了逻辑模式，物理部署和运维模式的选择对系统的便利性、可扩展性和成本效益有着决定性影响。现代架构主要围绕两大范式展开：基于容器编排的自托管平台和全托管的云服务（`DBaaS`）。

#### Kubernetes 方案：控制力与复杂性的权衡

对于追求最大化控制力和环境可移植性的团队，使用 `Docker` 和 `Kubernetes` 构建和管理 `MySQL` + `Redis` 堆栈是一种主流选择。

* **使用 Docker 进行容器化**：将 `MySQL` 和 `Redis` 分别打包到 `Docker` 容器中，可以实现环境的标准化和隔离，彻底解决“在我的机器上可以运行”的典型问题 [^6]。`Dockerfiles` 明确定义了服务的依赖、配置和启动方式，使得部署过程高度可复现 [^7]。

* **使用 Kubernetes (K8s) 进行编排**：`Kubernetes` 作为一个容器编排平台，能够自动化容器化应用的部署、扩展和管理 [^7]。
  * **核心概念**：通过 `Pods`（运行容器的最小单元）、`Services`（提供稳定的网络端点）和 `Deployments`/`StatefulSets`（管理应用生命周期和副本数量），`K8s` 可以确保 `MySQL` + `Redis` 服务的高可用性。当某个 `Pod` 发生故障时，`K8s` 会自动重新调度并启动一个新的 `Pod` 来替代它 [^9]。
  * **挑战**：尽管功能强大，但 `K8s` 的学习曲线相当陡峭。运维团队需要处理持久化存储（`PersistentVolumes`）、网络策略、`Ingress` 控制器等复杂的“底层管道”问题 [^10]。相比于 `Docker Compose` 或 `Docker Swarm` 等更简单的工具，`K8s` 的初始设置和持续维护需要更高的技术投入 [^10]。

#### 托管服务 (DBaaS) 方案：简单性与可扩展性的融合

对于希望将工程资源集中在应用开发而非基础设施管理上的团队，各大云厂商提供的数据库即服务（`DBaaS`）是更优选。

* **核心价值主张**：托管服务，如 `AWS RDS for MySQL`、`AWS ElastiCache for Redis` [^5]、`Google Cloud SQL` 以及 `Google Cloud Memorystore for Redis` [^12]，其核心价值在于将繁琐的运维工作抽象化。开发者无需关心服务器配置、操作系统补丁、软件更新、备份和扩展等问题，只需通过控制台或 API 点击几下，即可在数分钟内启动一个生产级的数据库集群 [^12]。

* **关键特性**：
  * **无忧设置与维护**：云平台负责所有底层的硬件和软件维护，开发者可以专注于应用逻辑 [^12]。
  * **高可扩展性**：支持随时垂直扩展（升级实例规格）或水平扩展（增加只读副本或分片），且对应用影响极小 [^11]。
  * **自动化备份与恢复**：提供每日自动备份和任意时间点恢复（Point-in-Time Recovery）功能，大大增强了数据安全性 [^14]。
  * **自动化故障转移**：在多可用区（Multi-AZ）部署模式下，一旦主节点发生故障，系统会自动切换到备用节点，最大程度地保证服务的可用性 [^14]。
  * **端到端安全**：数据库运行在隔离的私有网络（`VPC`）中，支持静态数据加密和传输中加密，并通过 `IAM` 进行精细的访问控制 [^12]。

* **主流云平台架构实践**：
  * **AWS 平台**：最佳实践是将 `RDS for MySQL` 和 `ElastiCache for Redis` 部署在同一个 `VPC` (Virtual Private Cloud) 内的不同私有子网中，通过安全组策略控制它们之间的访问，以实现低延迟和高安全性。一个重要的成本优化策略是，使用 `ElastiCache` 来缓存读请求，从而显著减少对昂贵的 `RDS` 只读副本的需求。研究表明，这种架构可以节省高达 55% 的成本，并带来高达 80 倍的读取性能提升 [^5]。此外，`AWS Database Migration Service (DMS)` 还可以作为一个强大的工具，用于实现从 `RDS` 到 `ElastiCache` 的持续数据复制，以保证缓存的实时性 [^18]。
  * **Google Cloud 平台**：GCP 的 `Memorystore for Redis` 提供了不同的服务层级，包括用于高可用的标准层（Standard Tier），它跨区域复制数据并提供 99.9% 的可用性 SLA [^12]。`Memorystore` 完全兼容开源 `Redis` 协议，这意味着现有的应用无需任何代码修改即可迁移 [^12]。它与 Google Cloud 的监控（`Cloud Monitoring`）、日志（`Cloud Logging`）和身份与访问管理（`IAM`）等服务深度集成，提供了全面的可观测性和安全性 [^19]。

#### 对比决策：Kubernetes 自托管 vs. 托管云服务

| 特性 | Kubernetes (自托管) | 托管服务 (DBaaS) |
| :--- | :--- | :--- |
| **初始设置复杂度** | 非常高，需要专业的 K8s 知识 | 极低，通过 UI 或 API 几分钟内完成 |
| **持续维护开销** | 高，需要负责版本升级、补丁、监控和故障排查 | 极低，由云服务商完全负责 |
| **扩展的便捷性** | 中等，需要手动配置 HPA/VPA 和存储扩容 | 非常高，通常支持一键式或自动化扩展 |
| **高可用性配置** | 复杂，需要手动配置多副本、持久化存储和故障转移逻辑 | 简单，通常只需勾选“多可用区部署”选项 |
| **备份与恢复** | 复杂，需要自行实施和管理备份策略（如 Velero） | 简单，提供自动化、托管的备份和时间点恢复 |
| **安全管理** | 复杂，需自行配置网络策略、RBAC、密钥管理等 | 简单，集成云平台的安全体系（IAM、VPC、KMS） |
| **总体拥有成本 (TCO)** | 潜在较低的硬件成本，但人力成本非常高 | 较高的直接服务费用，但显著降低了人力和运维成本 |
| **定制化与控制力** | 极高，可以完全控制每个配置参数 | 有限，受限于服务商提供的选项 |
| **厂商锁定风险** | 低，K8s 是开源标准，可跨云部署 | 高，深度依赖特定云服务商的 API 和生态 |
| **团队技能要求** | 需要专业的 DevOps 和 Kubernetes 专家 | 较低，普通应用开发者即可轻松使用 |

选择 `Kubernetes` 还是托管服务，本质上是一个关于组织工程资源投向的战略决策。选择 `Kubernetes` 意味着企业决心投资于构建一个强大的内部平台工程能力，以换取长期的灵活性和控制力。而选择 `DBaaS` 则表明企业优先考虑加速应用层面的创新和产品交付速度，愿意为此将基础设施的管理外包给更专业的云服务提供商。对于绝大多数非科技巨头的企业而言，其核心竞争力在于业务应用本身，而非底层基础设施的运维。因此，用户所寻求的“先进架构”，可能并非一个更复杂的技术堆栈，而是一个更简洁的运维模型（`DBaaS`），它能将宝贵的工程师从繁琐的运维工作中解放出来，投入到能直接创造业务价值的活动中去。

## 第二部分：先进与替代性数据库架构

在精通 `MySQL` + `Redis` 架构的基础上，本部分将视野拓展至更前沿的数据库解决方案。这些方案或通过功能整合简化技术栈，或通过创新的分布式设计从根本上解决传统架构的可扩展性与一致性难题，为处理复杂元数据和查询场景提供了全新的思路。

### 2.1 “PostgreSQL 万能论”范式

近年来，“用 `PostgreSQL` 搞定一切”（Postgres for Everything）的理念在开发者社区中日益盛行 [^21]。这一范式主张利用 `PostgreSQL` 自身强大的、可扩展的特性，来统一处理传统上需要由多个独立系统（如 `MySQL` 用于事务，`Redis` 用于缓存，甚至 `MongoDB` 用于文档存储）协作完成的任务，从而大幅降低系统架构的复杂性。

#### PostgreSQL vs. MySQL：功能维度的超越

长期以来，`MySQL` 因其易用性和在早期互联网 `LAMP` 架构中的主导地位而广受欢迎 [^22]。然而，`PostgreSQL` 凭借其对 SQL 标准的严格遵循、更强大的查询优化器以及一系列先进的功能，逐渐成为构建复杂、严肃应用的首选 [^22]。其在数据类型、索引机制和可扩展性上的优势，使其不仅仅是 `MySQL` 的一个替代品，更是一个功能强大的数据管理平台 [^21]。

#### 使用 JSONB 处理复杂元数据

`PostgreSQL` 对半结构化数据的原生支持是其核心优势之一，这直接满足了用户处理“复杂元数据”的需求。

* **`JSON` vs. `JSONB` 的关键区别**：`PostgreSQL` 提供了两种 `JSON` 数据类型。`json` 类型以纯文本形式存储输入的 `JSON` 数据，保留了原始的空格、缩进和键的顺序。而 `jsonb` 类型则将数据存储为一种分解后的二进制格式 [^25]。这种二进制格式在写入时需要额外的转换开销，导致插入速度略慢于 `json` 类型；但其优势在于查询时无需重复解析，处理速度显著加快，并且 `jsonb` 支持高级索引，这使其在绝大多数应用场景中成为首选 [^27]。

* **`JSONB` 的应用场景**：`JSONB` 非常适合存储那些结构多变或无法预先完全定义的半结构化数据。典型的应用场景包括：
  * **产品目录**：不同类别的商品拥有截然不同的属性（如衣服有尺码颜色，电子产品有规格参数）。使用 `JSONB` 可以在一个字段内灵活存储这些异构属性 [^30]。
  * **用户偏好设置**：用户的配置信息可能会随着应用功能的迭代而不断增加，`JSONB` 可以轻松容纳这些新增的字段而无需修改表结构 [^29]。
  * **事件日志与审计追踪**：事件的载荷（payload）结构多变，`JSONB` 能够以其原生格式高效存储和查询这些事件数据 [^29]。

* **混合数据模型最佳实践**：最有效的设计模式是采用混合模型，即结合使用传统的关系型列和 `JSONB` 列 [^30]。将那些结构稳定、查询频繁、需要强制约束或作为外键的字段（如 `product_id`, `price`, `category_id`）存储在标准列中；而将那些动态、稀疏或嵌套的属性存储在一个 `JSONB` 字段（如 `attributes`）中 [^30]。这种方法既利用了关系模型的完整性和性能优势，又享受了文档模型的灵活性，实现了“两全其美” [^30]。

#### 使用 GIN 索引进行高级查询

`JSONB` 的真正威力在于其与 `PostgreSQL` 先进索引能力的结合，特别是 `GIN` 索引。

* **`GIN` 索引工作原理**：`GIN`（Generalized Inverted Index，通用倒排索引）专为索引包含多个元素的复合值（如数组或 `JSONB`）而设计。对于一个 `JSONB` 列，`GIN` 索引会为其中的每个键或值创建一个索引条目，并指向包含该键或值的所有文档 [^32]。这使得基于 `JSONB` 内容的查找，尤其是存在性检查和包含关系查询，变得极其高效，避免了对全表的慢速顺序扫描 [^34]。

* **`jsonb_ops` vs. `jsonb_path_ops`**：在使用 `GIN` 索引时，可以选择不同的操作符类（operator class）以优化特定类型的查询。
  * `jsonb_ops`（默认）：为 `JSONB` 文档中的**每一个键和值**都创建索引。它功能全面，支持存在性操作符（如 `?`, `?|`, `?&`）和包含操作符（`@>`）[^31]。
  * `jsonb_path_ops`：这是一个更优化的版本，它只为 `JSONB` 文档中的**值**创建索引条目（以哈希形式）。这使得索引体积更小，对于只关心值匹配的包含查询（`@>`）性能更高 [^33]。

#### 使用 UNLOGGED 表作为缓存

为了替代 `Redis`，`PostgreSQL` 提供了一种特殊的表类型——`UNLOGGED` 表 [^36]。

* **工作机制**：默认情况下，`PostgreSQL` 的所有写操作都会先写入预写日志（Write-Ahead Log, WAL）以保证事务的持久性。`UNLOGGED` 表则跳过了这一步，数据直接写入表文件，不记录 WAL。这极大地减少了写操作的 I/O 开销，使其写入性能接近内存数据库 [^36]。

* **性能与持久性的权衡**：这种性能提升的代价是牺牲了数据的持久性。由于没有 WAL 记录，一旦数据库发生崩溃或服务器异常关闭，`UNLOGGED` 表中的所有数据将会被自动清空，无法恢复 [^36]。这种特性使其非常适合存储临时性、可丢失的数据，例如会话状态（session store）或缓存层。

* **与 `Redis` 的性能对比**：尽管 `UNLOGGED` 表的写性能优异，但其读性能相比普通表并没有显著提升，因为 `PostgreSQL` 的读性能主要依赖于共享内存缓冲区（shared buffers）的缓存机制 [^36]。与专门为内存操作优化的 `Redis` 相比，`PostgreSQL` 在读写两方面仍然存在较大差距。基准测试显示，`Redis` 的读写延迟远低于 `PostgreSQL` 的 `UNLOGGED` 表 [^36]。

综上所述，“`PostgreSQL` 万能论”的核心吸引力在于其能够显著降低**运维复杂性**。管理一个功能强大的数据库，远比维护、监控、保障两个或多个异构系统之间的数据一致性要简单得多。这种架构上的简化，是以牺牲专用内存数据库（如 `Redis`）的极致性能为代价的。因此，技术决策的关键在于评估：应用的性能瓶颈是否真的极端到必须依赖一个专门的内存数据库，还是说，单一数据库带来的运维简化和原生事务一致性在总体上更有价值？对于许多应用而言，后者往往是更明智的选择。

### 2.2 分布式 SQL (NewSQL) 的崛起

当单一节点的数据库（无论是 `MySQL` 还是 `PostgreSQL`）遭遇容量或写入性能瓶颈时，传统的解决方案是垂直扩展（升级硬件）或手动分片（sharding）。然而，这两种方法都存在明显的局限性。分布式 SQL（也称 `NewSQL`）的出现，旨在从根本上解决这一问题，它将关系型数据库的 `ACID` 事务保证与 `NoSQL` 的水平扩展能力结合在一起 [^38]。

#### 核心架构理念

`NewSQL` 数据库并非在传统单体数据库之上打补丁，而是从一开始就为分布式环境设计。其架构通常包含以下几个核心理念：

* **计算与存储分离**：许多 `NewSQL` 数据库采用分层架构，将无状态的 SQL 计算层与分布式的存储层分离开来。这使得计算资源和存储资源可以根据负载需求独立扩展 [^40]。

* **自动化分片**：数据被自动地、透明地切分成较小的数据块（在 `TiDB` 中称为 "Region"，在 `CockroachDB` 中称为 "Range"），并均匀分布到集群中的所有存储节点上。当数据增长或节点增减时，系统会自动进行数据的分裂和迁移（rebalancing），对应用层完全透明 [^42]。

* **基于共识协议的复制**：为了在分布式环境中保证数据的一致性和高可用性，`NewSQL` 数据库普遍采用 `Raft` 或 `Paxos` 这样的共识协议 [^45]。一笔事务的写入操作，必须在大多数（一个法定数量，即 quorum）副本节点上确认后，才被视为提交成功。这确保了即使部分节点发生故障，数据也不会丢失，并且系统能够继续提供服务 [^41]。

#### 案例研究 1：TiDB - 兼容 MySQL 的可扩展数据库

`TiDB` 是一个开源的分布式 SQL 数据库，以其对 `MySQL` 协议的高度兼容性和水平扩展能力而闻名。

* **架构概览**：`TiDB` 集群由三个核心组件构成 [^41]：
  * **`TiDB Server`**：无状态的 SQL 计算层，负责接收客户端请求、解析 SQL、生成执行计划。可以水平扩展以增加 SQL 处理能力。
  * **`TiKV Server`**：分布式的、事务性的键值存储层，负责数据的持久化存储。数据以 `Region` 为单位在 `TiKV` 节点间通过 `Raft` 协议进行复制和管理。
  * **`Placement Driver (PD)`**：整个集群的“大脑”，负责存储元数据（如 `Region` 的位置信息）、调度数据迁移和负载均衡，并分配全局唯一的时间戳。

* **解决 `MySQL` 手动分片的痛点**：`TiDB` 的核心价值在于，它为深受手动分片之苦的 `MySQL` 用户提供了一个原生的、自动化的解决方案。手动分片的运维痛点包括 [^44]：
  * **分片键选择**：需要预先设计分片策略，一旦选定难以更改。
  * **跨分片事务**：原生 `MySQL` 不支持，需要应用层实现复杂的两阶段提交（2PC）或接受最终一致性。
  * **查询路由**：应用或中间件需要知道数据在哪个分片上，增加了业务逻辑的复杂性。
  * **扩容与再平衡**：增加新分片或处理数据热点时，需要复杂且高风险的手动数据迁移。
    `TiDB` 的架构通过自动化分片和分布式事务，从根本上解决了所有这些问题，使扩展变得简单而透明 [^40]。

* **`MySQL` 兼容性**：`TiDB` 实现了对 `MySQL` 5.7 和 8.0 版本协议及常用语法的高度兼容 [^50]。这意味着绝大多数现有的 `MySQL` 应用、客户端和生态工具（如 `Navicat`, `DBeaver`）都可以无缝地迁移到 `TiDB`，而无需或只需极少的代码修改 [^47]。这是一个巨大的迁移优势。需要注意的是，`TiDB` 并不支持 `MySQL` 的原生复制协议，而是提供了专门的数据迁移和同步工具 [^50]。

* **混合事务/分析处理 (HTAP)**：通过引入 `TiFlash` 这一列式存储副本，`TiDB` 可以在同一个集群内同时高效处理在线事务处理（OLTP）和在线分析处理（OLAP）负载 [^41]。`TiFlash` 通过 `Raft Learner` 协议实时从 `TiKV` 复制数据，并将其转换为列式格式。这意味着业务系统可以在最新的事务数据上直接运行复杂的分析查询，而无需构建和维护独立的、有延迟的 ETL 管道和数据仓库 [^52]。

* **成功案例**：全球知名的通讯应用公司 LINE，就因其庞大的 `MySQL` 集群（约 7000 个实例）面临巨大的运维负担和扩展瓶颈，最终选择将部分核心业务从手动分片的 `MySQL` 迁移至 `TiDB`，解决了运维过载和扩展性问题 [^53]。

#### 案例研究 2：CockroachDB - 弹性、兼容 PostgreSQL 的数据库

`CockroachDB` 是另一款领先的分布式 SQL 数据库，其设计哲学深受 Google Spanner 的影响，并以其卓越的弹性和对 `PostgreSQL` 协议的兼容性著称。

* **架构概览**：`CockroachDB` 采用对称的、无共享（shared-nothing）的架构，集群中的每个节点都是对等的，都可以接收读写请求 [^54]。数据被切分为 `Ranges`（约 512 MiB），每个 `Range` 至少有三个副本，通过 `Raft` 协议分布在不同的节点上，以实现高可用性和一致性 [^43]。

* **高可用性与弹性**：这是 `CockroachDB` 最突出的优势。其架构设计使其能够自动应对节点甚至整个可用区（AZ）级别的故障 [^54]。当一个节点宕机时，`Raft` 协议会自动在其副本组内选举出新的领导者，集群可以继续无中断地处理读写请求。同时，系统会检测到副本数的不足，并自动在其他健康节点上创建新的副本，以恢复到预设的冗余级别 [^55]。这与传统 `PostgreSQL` 主从架构中复杂、易出错且可能导致数据丢失的手动故障转移流程形成了鲜明对比 [^55]。

* **`PostgreSQL` 兼容性**：`CockroachDB` 实现了与 `PostgreSQL` 的网络协议兼容，这意味着大多数为 `PostgreSQL` 开发的驱动、ORM 框架和工具都可以直接用于 `CockroachDB` [^54]。然而，需要明确的是，这种兼容性并非 100%。由于分布式系统的内在复杂性，一些 `PostgreSQL` 的高级特性（如存储过程、某些特定数据类型）可能不受支持或行为有所不同 [^57]。

* **地理分区 (Geo-Partitioning)**：`CockroachDB` 提供了强大的地理分布能力。它允许在行级别（row-level）上将数据绑定到特定的地理区域，以满足数据主权（data residency）的合规性要求，并能通过将数据置于用户附近来显著降低读写延迟 [^54]。

* **成功案例**：印度的一家新兴数字银行（neobank）Fi，在评估了 `Spanner`、`TiDB` 等多种方案后，最终选择 `CockroachDB` 作为其核心金融账本的数据库。他们看重的是 `CockroachDB` 提供的弹性、强一致性事务保证，以及与 `PostgreSQL` 的兼容性，这使得他们熟悉 `Postgres` 的团队能够平滑过渡 [^60]。

分布式 SQL 的出现，标志着由 Google 等超大规模公司开创的复杂分布式系统工程技术的商品化。`TiDB` 和 `CockroachDB` 等数据库，将曾经只有科技巨头才能负担得起的水平扩展能力和高弹性，以开源或商业产品的形式带给了广大企业。采用这类数据库，不仅仅是一次技术升级，更是一项战略决策——它意味着企业可以借助一个成熟的、开箱即用的解决方案，来应对否则需要一个庞大、专业的平台工程团队从零开始才能解决的规模化和可靠性挑战。这从根本上改变了企业在构建可扩展、高可靠数据库时“自建与购买”的平衡。

### 2.3 专用与多模型数据库架构

随着应用需求的日益复杂化，“一个数据库包打天下”的模式面临挑战。这催生了两种主流的架构思想：一是“多语言持久化”（Polyglot Persistence），即为不同的任务选择最合适的专用数据库，并将它们组合使用；二是采用“多模型数据库”，即在一个统一的数据库内核中支持多种数据模型，以简化技术栈。

#### RDBMS + Elasticsearch：应对复杂搜索的黄金组合

当应用的查询需求超越了标准 SQL 的能力范围，特别是涉及全文搜索、相关性排序、模糊匹配和复杂聚合分析时，引入一个专门的搜索引擎就变得至关重要。

* **为何选择 `Elasticsearch`**：`Elasticsearch` 是一个基于 `Lucene` 构建的分布式搜索引擎，它在处理非结构化文本数据、提供高级搜索功能方面表现卓越 [^61]。它被广泛应用于各种场景，从电商网站的商品搜索，到日志分析平台，再到大型代码托管平台的内容检索。例如，`GitHub` 使用 `Elasticsearch` 索引数十亿份文档以支持其强大的代码搜索功能 [^63]，而 `Docusign` 则利用它来快速检索数百万份电子协议 [^64]。

* **架构模式**：最佳实践是将关系型数据库（如 `PostgreSQL` 或 `MySQL`）作为**记录系统 (System of Record)**，保证数据的事务一致性和完整性；同时，将 `Elasticsearch` 作为**次级索引 (Secondary Index)**，存储一份为搜索优化的、可能经过非规范化处理的数据副本 [^65]。这种架构分离了事务处理和搜索分析的负载，使得每个系统都能发挥其最大优势。

* **数据同步管道 (CDC)**：该架构中最关键、也最具挑战性的部分是如何保持 RDBMS 和 `Elasticsearch` 之间的数据实时同步。有三种主要方法 [^67]：
    1. **同步双写**：应用在更新数据库的同时，同步更新 `Elasticsearch`。这种方法实现简单，但非常脆弱，容易因其中一个系统失败而导致数据不一致，不推荐在生产环境使用。
    2. **异步双写（通过消息队列）**：应用更新数据库后，发送一条消息到消息队列（如 `RabbitMQ`），由一个独立的消费者服务来更新 `Elasticsearch`。这种方式提高了可靠性，但将同步逻辑与业务应用紧密耦合。
    3. **变更数据捕获 (Change Data Capture - CDC)**：这是最健壮、最解耦的方案 [^67]。通过使用 `Debezium` 或 `Canal` 等工具监听数据库的事务日志（如 `MySQL` 的 `binlog` 或 `PostgreSQL` 的 `WAL`），捕获所有数据变更事件。这些事件被发送到像 `Kafka` 这样的高吞吐量、持久化的消息总线中。最后，由 `Logstash` 或一个自定义的消费者服务从 `Kafka` 读取这些事件，并将其应用到 `Elasticsearch` 中 [^66]。这个流程是异步的、可靠的，并且对源数据库的性能影响极小。

* **挑战**：尽管功能强大，这种“`RDBMS` + `ES`”的组合架构也带来了显著的运维复杂性。团队需要部署、监控和维护整个 CDC 管道，处理数据同步的延迟问题，设计 schema 变更的管理流程，并建立数据校验机制以确保两个系统间的最终一致性 [^61]。

#### ArangoDB 的多模型方法：简化技术栈

与“多语言持久化”将多个数据库组合的方式相反，多模型数据库旨在通过一个统一的平台来满足多样化的数据存储需求。

* **什么是原生多模型数据库**：`ArangoDB` 是一个典型的原生多模型数据库，其单一的数据库内核同时支持**文档 (Document)**、**图 (Graph)** 和**键值 (Key-Value)** 三种数据模型 [^68]。用户可以通过一种统一的查询语言——`AQL` (ArangoDB Query Language)，在一次查询中无缝地混合使用这些数据模型 [^70]。

* **核心价值：数据库整合**：`ArangoDB` 的主要优势在于能够大幅简化技术栈。对于一个需要处理结构化数据、文档元数据以及数据间复杂关系的应用，传统方法可能需要同时部署一个关系型数据库、一个文档数据库（如 `MongoDB`）和一个图数据库（如 `Neo4j`）。而 `ArangoDB` 可以用一个系统替代这三者，从而减少了数据冗余、跨系统数据同步的复杂性以及运维成本 [^70]。

* **`AQL` - 统一查询语言**：`AQL` 是一种功能强大的声明式查询语言，它借鉴了 SQL 的语法，并融合了数据流处理的概念 [^72]。它允许开发者在单个查询中执行复杂的 `JOIN` 操作、多跳的图遍历、全文搜索以及聚合分析，极大地增强了数据查询的表达能力 [^73]。

* **应用案例**：在实际应用中，企业利用 `ArangoDB` 的多模型能力解决了复杂的业务问题。例如，制造数据管理公司 Actify 使用 `ArangoDB`，将产品的基础信息存储为文档，同时将产品零部件之间的装配关系（物料清单，BOM）建模为图，从而高效地管理复杂的产品结构 [^74]。

#### MongoDB 的文档导向方法

当应用的核心数据模型天然地以文档形式存在时，选择一个文档原生的数据库如 `MongoDB` 往往是最高效的选择。

* **适用场景**：`MongoDB` 适用于那些数据结构复杂、嵌套层次深、且 schema 频繁演进的场景 [^75]。其灵活的 schema 模型允许开发者快速迭代，而无需像关系型数据库那样频繁地执行成本高昂的 schema 变更 [^77]。

* **复杂元数据建模**：`MongoDB` 通过内嵌文档（embedded documents）和数组（arrays）来支持非规范化的数据建模 [^77]。将相关联的数据聚合在单个文档中，可以减少甚至消除传统数据库中昂贵的 `JOIN` 操作，从而在一次数据库读取中获取所有需要的信息，极大地提升了读取性能 [^79]。

* **聚合框架 (Aggregation Framework)**：对于超出简单 CRUD 操作的复杂查询和分析需求，`MongoDB` 提供了强大的聚合框架 [^80]。它以一个多阶段的管道（pipeline）形式工作，数据文档依次通过 `$match`（过滤）、`$group`（分组）、`$unwind`（展开数组）、`$lookup`（类似 `LEFT JOIN`）、`$project`（重塑文档）等一系列操作符进行转换和处理，最终生成分析结果 [^81]。例如，通过聚合管道可以轻松地生成按产品分类的销售额报告，或按月统计用户注册数量等复杂的业务报表 [^80]。

* **与 `PostgreSQL` `JSONB` 的对比**：虽然 `PostgreSQL` 的 `JSONB` 提供了强大的文档存储和查询能力，但 `MongoDB` 作为一个文档原生数据库，在开发者体验、生态系统以及原生水平扩展（sharding）方面通常更具优势 [^75]。对于以文档为中心的应用，`MongoDB` 的查询语言（MQL）和数据模型更为直观。

选择“多语言持久化”架构（如 `RDBMS` + `ES`）还是整合型数据库（如 `ArangoDB` 或 `MongoDB`），反映了在**特定任务的极致性能**与**整体架构的简洁性**之间的根本权衡。前者通过专用工具的组合，可以在事务处理和复杂搜索等领域达到业界顶尖的性能水平，但其代价是高昂的运维和同步成本。后者则通过技术栈的整合，牺牲了部分专用性，换取了开发效率的提升、运维负担的减轻以及跨模型数据一致性的简化。一个拥有成熟平台工程团队的大型企业，可能会选择前者以追求性能极限；而一个希望快速迭代、资源有限的初创团队，则可能更倾向于后者，以降低复杂性、加速产品交付。

## 第三部分：战略建议与决策框架

经过对 `MySQL` + `Redis` 传统架构的深度优化，以及对 `PostgreSQL`、分布式 SQL、专用搜索和多模型数据库等先进替代方案的全面分析，本部分旨在将这些技术洞察转化为一个实用的、可操作的决策框架。其目标是帮助技术领导者根据其具体的业务场景、技术栈和团队能力，做出明智且具有前瞻性的架构选择。

### 3.1 综合决策矩阵

为了直观地比较所有讨论过的架构范式，下表从多个关键维度对其进行了评估。这个矩阵是整个报告分析的核心摘要，旨在为高层次的架构选型提供一个清晰、全面的参考。
**数据库架构综合决策矩阵**

| 维度 | MySQL + Redis | PostgreSQL-Only | TiDB (分布式 SQL) | CockroachDB (分布式 SQL) | RDBMS + Elasticsearch | ArangoDB (多模型) | MongoDB (文档型) |
| :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- |
| **主要数据模型** | 关系型 + 键值 | 关系型 + 文档 (JSONB) | 关系型 | 关系型 | 关系型 + 搜索文档 | 文档, 图, 键值 | 文档 |
| **扩展模型** | 垂直扩展 + 手动分片 | 垂直扩展 | 原生水平扩展 | 原生水平扩展 | 独立扩展 | 水平扩展 | 原生水平扩展 |
| **强一致性 (ACID)** | 跨系统弱 (最终一致) | 是 (单机事务) | 是 (分布式事务) | 是 (分布式事务) | 跨系统弱 (最终一致) | 是 (可配置) | 是 (多文档事务) |
| **运维复杂性** | 高 (需维护两个系统及同步) | 低 | 中 (分布式系统运维) | 中 (分布式系统运维) | 非常高 (需维护 CDC 管道) | 中 | 中 |
| **生态与兼容性** | 极好 (MySQL 生态) | 极好 (PostgreSQL 生态) | 好 (兼容 MySQL) | 好 (兼容 PostgreSQL) | 极好 (各自独立生态) | 中等 | 极好 (尤其 Node.js) |
| **总体拥有成本 (TCO)** | 中等 (服务费 + 运维人力) | 低 | 中高 (集群资源 + 运维) | 中高 (集群资源 + 运维) | 高 (服务费 + 管道成本) | 中等 | 中等 |
| **最佳应用场景** | 通用 Web 应用、需要高性能缓存的读密集型负载 | 业务逻辑复杂、需要灵活元数据存储、追求架构简洁性的应用 | 超大规模 OLTP、MySQL 手动分片的替代方案、HTAP | 高可用、高弹性、地理分布式应用、PostgreSQL 兼容性需求 | 核心功能依赖复杂搜索、全文检索、日志分析的应用 | 知识图谱、社交网络、360度客户视图、需要整合多数据模型的应用 | 内容管理、物联网、移动应用后端、以文档为核心的半结构化数据应用 |

### 3.2 常见场景的架构蓝图

基于上述分析，以下为四种典型应用场景提供了具体的、带有明确倾向性的架构蓝图建议。

#### 蓝图 A：现代化可扩展标准型 (PostgreSQL + Redis on K8s/DBaaS)

* **适用场景**：绝大多数需要坚实关系型数据基础和高性能缓存的通用 Web 应用、SaaS 服务和内容平台。这是对于读密集型负载最经典、最成熟的优化方案。

* **架构建议**：
    1. **数据库选择**：推荐使用 **`PostgreSQL`** 替代 `MySQL`。其对 `JSONB` 的原生支持、更强大的索引能力和查询优化器，为处理未来可能出现的复杂数据需求提供了更好的基础 [^21]。
    2. **缓存层**：继续使用 **`Redis`** 作为高性能缓存层，采用“先更新数据库，再删除缓存”的 **`Cache-Aside`** 模式作为基础策略。对于一致性要求更高的场景，应考虑引入基于数据库日志的 **`CDC` 方案**进行缓存失效。
    3. **部署模式**：在 **托管服务 (`DBaaS`)** 和 **`Kubernetes`** 之间选择。对于大多数团队，推荐使用 `AWS RDS for PostgreSQL` + `ElastiCache` 或 `GCP Cloud SQL` + `Memorystore` 的组合，以最大程度地降低运维负担，让团队专注于业务开发 [^12]。只有当组织具备强大的平台工程能力，或有特定的定制化、多云部署需求时，才应考虑在 `Kubernetes` 上自托管。

* **结论**：这是适用于广泛场景的“默认”最佳实践，平衡了性能、成本和成熟度。

#### 蓝图 B：高增长事务平台 (分布式 SQL)

* **适用场景**：预计将面临海量事务性写入、需要从第一天起就具备水平扩展能力和极高可用性的应用。例如：金融科技（支付、账本）、大型电商（订单系统）、物联网（设备数据采集）等。

* **架构建议**：
    1. **数据库选择**：直接采用**分布式 SQL 数据库**，以避免未来进行痛苦且高风险的手动分片迁移。
    2. **具体方案**：
        * 如果现有技术栈或团队经验偏向 **`MySQL`**，**`TiDB`** 是理想选择。其高度的 `MySQL` 兼容性可以大大降低迁移成本和学习曲线 [^47]。
        * 如果技术栈偏向 **`PostgreSQL`**，或者对系统的弹性和地理分布能力有极致要求，**`CockroachDB`** 是更优的选择。其自动故障恢复能力和对多区域部署的原生支持是其核心优势 [^54]。

* **结论**：对于写入密集型和需要线性扩展的应用，分布式 SQL 不是未来的选项，而是当下的最佳实践。它将复杂的分布式系统问题在数据库层面解决，极大地简化了应用层的架构。

#### 蓝图 C：复杂搜索与分析应用 (RDBMS + Elasticsearch)

* **适用场景**：搜索和数据探索是应用核心功能的应用。例如：具有复杂筛选和排序功能的电商产品目录、日志聚合与分析平台、知识库或内容管理系统。

* **架构建议**：
    1. **架构模式**：采用“**多语言持久化**”思想，明确职责分离。
    2. **记录系统**：使用 **`PostgreSQL`** 作为主数据库，存储规范化的、权威的源数据，并利用其 `ACID` 事务保证数据的完整性。
    3. **搜索系统**：使用 **`Elasticsearch`** 作为专门的搜索引擎。所有需要被搜索的数据，都从 `PostgreSQL` 同步至 `Elasticsearch` 的索引中。应用的所有复杂查询、全文搜索、聚合分析请求都直接发送到 `Elasticsearch` [^61]。
    4. **同步机制**：构建一个基于 **`CDC`（变更数据捕获）** 的实时数据管道。使用 **`Debezium`** 从 `PostgreSQL` 的 `WAL` 中捕获变更，通过 **`Kafka`** 进行缓冲和解耦，最后由 **`Logstash`** 或自定义消费者将数据写入 `Elasticsearch` [^67]。

* **结论**：这是实现顶尖搜索体验的“不妥协”架构。虽然运维复杂性最高，但它为每个任务都选择了最专业的工具，能够提供其他单一方案无法比拟的查询性能和功能深度。

#### 蓝图 D：统一的多面数据平台 (多模型)

* **适用场景**：应用的数据具有高度关联性和多样的形态，且简化技术栈、降低运维复杂性是首要目标。例如：知识图谱、社交网络、360度客户视图平台、复杂的配置管理系统。

* **架构建议**：
    1. **数据库选择**：采用原生**多模型数据库**，如 **`ArangoDB`**。
    2. **数据建模**：在一个数据库实例中，同时使用其多种数据模型。例如，将实体（如用户、产品）存储为**文档**，将它们之间的关系（如“购买”、“关注”）存储为**图的边**，并利用其**键值**能力进行快速查找 [^68]。
    3. **查询**：使用统一的查询语言（如 **`AQL`**）在单个查询中跨越不同的数据模型进行操作，例如，从一个文档节点开始进行图遍历，并根据遍历路径上其他节点的文档属性进行过滤 [^72]。

* **结论**：当数据模型的复杂性成为主要挑战时，多模型数据库提供了一个优雅的整合方案。它避免了因维护多个异构数据库而产生的数据同步、事务一致性和运维开销问题，是应对“数据多样性”的有力武器。

### 3.3 最终综合与未来展望

在现代数据架构的演进中，两条看似矛盾却并行不悖的主线日益清晰：“**大一统整合**”与“**多语言持久化**”。

* **核心张力**：一方面，以 `PostgreSQL` (`JSONB`, 扩展) 和 `ArangoDB` (多模型) 为代表的技术趋势，正推动着数据库能力的整合，旨在通过一个更强大、更通用的系统来简化技术栈。另一方面，以 `Redis` (内存计算) 和 `Elasticsearch` (搜索) 为代表的专用系统，凭借其在特定领域的极致性能，证明了“为专业任务选择专业工具”的“多语言持久化”方法的有效性。正确的选择，取决于对应用最关键需求的坦诚评估：是亚毫秒级的缓存延迟，是强大的全文检索能力，还是运维的简洁与开发的高效？

* **未来趋势：分布式与托管化**：无论选择哪条路径，一个明确的行业趋势是，架构正在从单体的、自管理的模式，向分布式的、托管化的未来演进。无论是通过云厂商提供的 `DBaaS` 服务，还是采用云原生的分布式数据库，未来的数据架构将越来越多地将底层的运维复杂性抽象掉。这将使开发者能够从繁重的服务器管理、扩展规划和故障恢复工作中解放出来，更专注于构建能够直接创造业务价值的应用本身。

* **最终决策框架**：为了做出最适合自身情况的架构决策，建议技术领导者围绕以下五个核心问题进行深入思考：
    1. **数据的核心形态是什么？** 我的数据主要是关系型的、文档型的、图状的，还是混合的？
    2. **未来3-5年的写入规模预期如何？** 我的应用是否会面临需要水平扩展写入能力的挑战？
    3. **数据一致性的要求有多高？** 我能否接受最终一致性，还是必须保证严格的、跨操作的事务性？
    4. **团队的运维能力和意愿如何？** 我们是否有能力和资源去管理一个复杂的、多组件的基础设施？
    5. **业务的核心价值来源于什么？** 是高并发的事务处理，是智能的搜索发现，还是对数据间深层关系的分析？

通过结合本报告提供的深度分析，对这五个问题做出清晰的回答，将引导您的团队走向一个稳健、可扩展且面向未来的数据平台架构。

#### 引用的著作

[^1]: MySQL – 0x2B, 访问时间为 八月 7, 2025， [https://oldblog.gonwan.com/tag/mysql/](https://oldblog.gonwan.com/tag/mysql/)
[^2]: Java – 0x2B\|~0x2B, 访问时间为 八月 7, 2025， [https://oldblog.gonwan.com/category/java/](https://oldblog.gonwan.com/category/java/)
[^3]: foogaro/redis-gears-for-caching-patterns: RedisGears ... - GitHub, 访问时间为 八月 7, 2025， [https://github.com/foogaro/redis-gears-for-caching-patterns](https://github.com/foogaro/redis-gears-for-caching-patterns)
[^5]: Optimize cost and boost performance of RDS for MySQL using ..., 访问时间为 八月 7, 2025， [https://aws.amazon.com/blogs/database/optimize-cost-and-boost-performance-of-rds-for-mysql-using-amazon-elasticache-for-redis/](https://aws.amazon.com/blogs/database/optimize-cost-and-boost-performance-of-rds-for-mysql-using-amazon-elasticache-for-redis/)
[^6]: Why you use or not use docker? : r/PHP - Reddit, 访问时间为 八月 7, 2025， [https://www.reddit.com/r/PHP/comments/1ei0e6y/why_you_use_or_not_use_docker/](https://www.reddit.com/r/PHP/comments/1ei0e6y/why_you_use_or_not_use_docker/)
[^7]: Developing and deploying Spring Boot microservices on Kubernetes - LearnKube, 访问时间为 八月 7, 2025， [https://learnkube.com/spring-boot-kubernetes-guide](https://learnkube.com/spring-boot-kubernetes-guide)
[^9]: Kubernetes 101 - explaining the basics while running a Laravel application with Redis and MySQL. - madewithlove, 访问时间为 八月 7, 2025， [https://madewithlove.com/blog/kubernetes-101-the-basics/](https://madewithlove.com/blog/kubernetes-101-the-basics/)
[^10]: How hard is it to move from Docker to Kubernetes? - Reddit, 访问时间为 八月 7, 2025， [https://www.reddit.com/r/kubernetes/comments/17kzz0p/how_hard_is_it_to_move_from_docker_to_kubernetes/](https://www.reddit.com/r/kubernetes/comments/17kzz0p/how_hard_is_it_to_move_from_docker_to_kubernetes/)
[^11]: Best practices for sizing your Amazon ElastiCache for Redis clusters | AWS Database Blog, 访问时间为 八月 7, 2025， [https://aws.amazon.com/blogs/database/best-practices-for-sizing-your-amazon-elasticache-for-redis-clusters/](https://aws.amazon.com/blogs/database/best-practices-for-sizing-your-amazon-elasticache-for-redis-clusters/)
[^12]: Memorystore for Redis overview | Google Cloud, 访问时间为 八月 7, 2025， [https://cloud.google.com/memorystore/docs/redis/memorystore-for-redis-overview](https://cloud.google.com/memorystore/docs/redis/memorystore-for-redis-overview)
[^14]: Take the worry out of managing your MySQL & Redis databases - DigitalOcean, 访问时间为 八月 7, 2025， [https://www.digitalocean.com/blog/take-the-worry-out-of-managing-your-mysql-redis-databases](https://www.digitalocean.com/blog/take-the-worry-out-of-managing-your-mysql-redis-databases)
[^18]: Replicate your data from Amazon Aurora MySQL to Amazon ElastiCache for Redis using AWS DMS | AWS Database Blog, 访问时间为 八月 7, 2025， [https://aws.amazon.com/blogs/database/replicate-your-data-from-amazon-aurora-mysql-to-amazon-elasticache-for-redis-using-aws-dms/](https://aws.amazon.com/blogs/database/replicate-your-data-from-amazon-aurora-mysql-to-amazon-elasticache-for-redis-using-aws-dms/)
[^19]: GCP Memorystore for Redis Cluster - Splunk AppDynamics Documentation, 访问时间为 八月 7, 2025， [https://docs.appdynamics.com/observability/cisco-cloud-observability/en/cloud-and-infrastructure-monitoring/google-cloud-platform-observability/observe-google-cloud-platform-entities/gcp-database-and-storage-services/gcp-memorystore-for-redis-cluster](https://docs.appdynamics.com/observability/cisco-cloud-observability/en/cloud-and-infrastructure-monitoring/google-cloud-platform-observability/observe-google-cloud-platform-entities/gcp-database-and-storage-services/gcp-memorystore-for-redis-cluster)
[^21]: Why PostgreSQL Is the Bedrock for the Future of Data | TigerData, 访问时间为 八月 7, 2025， [https://www.tigerdata.com/blog/postgres-for-everything](https://www.tigerdata.com/blog/postgres-for-everything)
[^22]: Why do you choose MySQL over Postgres? : r/node - Reddit, 访问时间为 八月 7, 2025， [https://www.reddit.com/r/node/comments/rv6u8u/why_do_you_choose_mysql_over_postgres/](https://www.reddit.com/r/node/comments/rv6u8u/why_do_you_choose_mysql_over_postgres/)
[^25]: Documentation: 17: 8.14. JSON Types - PostgreSQL, 访问时间为 八月 7, 2025， [https://www.postgresql.org/docs/current/datatype-json.html](https://www.postgresql.org/docs/current/datatype-json.html)
[^27]: Optimal Scenarios for Using JSON vs JSONB in PostgreSQL - RisingWave, 访问时间为 八月 7, 2025， [https://risingwave.com/blog/optimal-scenarios-for-using-json-vs-jsonb-in-postgresql/](https://risingwave.com/blog/optimal-scenarios-for-using-json-vs-jsonb-in-postgresql/)
[^29]: PostgreSQL JSONB in .NET - Marek Sirkovský - Medium, 访问时间为 八月 7, 2025， [https://mareks-082.medium.com/postgresql-jsonb-in-net-25fbcc7b64b2](https://mareks-082.medium.com/postgresql-jsonb-in-net-25fbcc7b64b2)
[^30]: JSONB: PostgreSQL's Secret Weapon for Flexible Data Modeling ..., 访问时间为 八月 7, 2025， [https://medium.com/@richardhightower/jsonb-postgresqls-secret-weapon-for-flexible-data-modeling-cf2f5087168f](https://medium.com/@richardhightower/jsonb-postgresqls-secret-weapon-for-flexible-data-modeling-cf2f5087168f)
[^31]: JSONB PostgreSQL: How To Store & Index JSON Data - ScaleGrid, 访问时间为 八月 7, 2025， [https://scalegrid.io/blog/using-jsonb-in-postgresql-how-to-effectively-store-index-json-data-in-postgresql/](https://scalegrid.io/blog/using-jsonb-in-postgresql-how-to-effectively-store-index-json-data-in-postgresql/)
[^32]: How to Index JSONB Columns in PostgreSQL - TigerData, 访问时间为 八月 7, 2025， [https://www.tigerdata.com/learn/how-to-index-json-columns-in-postgresql](https://www.tigerdata.com/learn/how-to-index-json-columns-in-postgresql)
[^33]: Understanding Postgres GIN Indexes: The Good and the Bad, 访问时间为 八月 7, 2025， [https://pganalyze.com/blog/gin-index](https://pganalyze.com/blog/gin-index)
[^34]: "Big" data in a JSONB column - postgresql - Stack Overflow, 访问时间为 八月 7, 2025， [https://stackoverflow.com/questions/42134792/big-data-in-a-jsonb-column](https://stackoverflow.com/questions/42134792/big-data-in-a-jsonb-column)
[^36]: Can Postgres replace Redis as a cache? | by Raphael De Lio ..., 访问时间为 八月 7, 2025， [https://medium.com/redis-with-raphael-de-lio/can-postgres-replace-redis-as-a-cache-f6cba13386dc](https://medium.com/redis-with-raphael-de-lio/can-postgres-replace-redis-as-a-cache-f6cba13386dc)
[^38]: NewSQL Databases: A Comprehensive Guide - Number Analytics, 访问时间为 八月 7, 2025， [https://www.numberanalytics.com/blog/newsql-databases-ultimate-guide](https://www.numberanalytics.com/blog/newsql-databases-ultimate-guide)
[^40]: NewSQL in Depth Understanding Its Consistency and Scalability ..., 访问时间为 八月 7, 2025， [https://amarchenko.dev/blog/2024-03-13-new-sql/](https://amarchenko.dev/blog/2024-03-13-new-sql/)
[^41]: Mastering TiDB: Scalability, Performance, and High Availability, 访问时间为 八月 7, 2025， [https://www.pingcap.com/article/mastering-tidb-scalability-performance-and-high-availability/](https://www.pingcap.com/article/mastering-tidb-scalability-performance-and-high-availability/)
[^42]: Deep Dive - TiKV, 访问时间为 八月 7, 2025， [https://tikv.org/deep-dive/introduction/](https://tikv.org/deep-dive/introduction/)
[^43]: Architecture Overview - CockroachDB, 访问时间为 八月 7, 2025， [https://www.cockroachlabs.com/docs/stable/architecture/overview](https://www.cockroachlabs.com/docs/stable/architecture/overview)
[^44]: Unlocking the Power of TiDB: Native Sharding for Seamless Database Scalability - Mydbops, 访问时间为 八月 7, 2025， [https://www.mydbops.com/blog/tidb-native-sharding](https://www.mydbops.com/blog/tidb-native-sharding)
[^45]: Distributed SQL - Wikipedia, 访问时间为 八月 7, 2025， [https://en.wikipedia.org/wiki/Distributed_SQL](https://en.wikipedia.org/wiki/Distributed_SQL)
[^47]: Why NetEase Games Chose TiDB over Other Storage Solutions, 访问时间为 八月 7, 2025， [https://www.pingcap.com/case-study/why-we-chose-tidb-over-other-mysql-based-and-newsql-storage-solutions/](https://www.pingcap.com/case-study/why-we-chose-tidb-over-other-mysql-based-and-newsql-storage-solutions/)
[^50]: MySQL Compatibility | TiDB Docs, 访问时间为 八月 7, 2025， [https://docs.pingcap.com/tidb/stable/mysql-compatibility](https://docs.pingcap.com/tidb/stable/mysql-compatibility)
[^52]: Achieving Ultra-Low Latency in Financial Transactions with TiDB, 访问时间为 八月 7, 2025， [https://www.pingcap.com/article/achieving-ultra-low-latency-in-financial-transactions-with-tidb/](https://www.pingcap.com/article/achieving-ultra-low-latency-in-financial-transactions-with-tidb/)
[^53]: From MySQL to TiDB: LINE's Exploration with Distributed SQL, 访问时间为 八月 7, 2025， [https://www.pingcap.com/case-study/line-corporation-exploration-mysql-tidb/](https://www.pingcap.com/case-study/line-corporation-exploration-mysql-tidb/)
[^54]: CockroachDB Vs. PostgreSQL - Key Differences - Airbyte, 访问时间为 八月 7, 2025， [https://airbyte.com/data-engineering-resources/cockroachdb-vs-postgres](https://airbyte.com/data-engineering-resources/cockroachdb-vs-postgres)
[^55]: Comparing CockroachDB and PostgreSQL, 访问时间为 八月 7, 2025， [https://www.cockroachlabs.com/blog/postgresql-vs-cockroachdb/](https://www.cockroachlabs.com/blog/postgresql-vs-cockroachdb/)
[^57]: PostgreSQL Compatibility - CockroachDB, 访问时间为 八月 7, 2025， [https://www.cockroachlabs.com/docs/stable/postgresql-compatibility](https://www.cockroachlabs.com/docs/stable/postgresql-compatibility)
[^60]: Building a scalable neobank platform from scratch on CockroachDB, 访问时间为 八月 7, 2025， [https://www.cockroachlabs.com/customers/building-a-scalable-neobank-platform-from-scratch-on-cockroachdb/](https://www.cockroachlabs.com/customers/building-a-scalable-neobank-platform-from-scratch-on-cockroachdb/)
[^61]: Secondary indexes vs Using elastic search - DBA Stack Exchange, 访问时间为 八月 7, 2025， [https://dba.stackexchange.com/questions/325163/secondary-indexes-vs-using-elastic-search](https://dba.stackexchange.com/questions/325163/secondary-indexes-vs-using-elastic-search)
[^63]: GitHub uses Elasticsearch to index over 8 million code repositories | Elastic Customers, 访问时间为 八月 7, 2025， [https://www.elastic.co/customers/github](https://www.elastic.co/customers/github)
[^64]: Docusign uses generative AI to accelerate agreement management with Elastic | Elastic Customers, 访问时间为 八月 7, 2025， [https://www.elastic.co/customers/docusign](https://www.elastic.co/customers/docusign)
[^65]: Elasticsearch as a primary database - Elastic Discuss, 访问时间为 八月 7, 2025， [https://discuss.elastic.co/t/elasticsearch-as-a-primary-database/85733](https://discuss.elastic.co/t/elasticsearch-as-a-primary-database/85733)
[^66]: How to Sync MySQL to Elasticsearch in Real-Time (No Code + Logstash Options) | Estuary, 访问时间为 八月 7, 2025， [https://estuary.dev/blog/mysql-to-elasticsearch-real-time/](https://estuary.dev/blog/mysql-to-elasticsearch-real-time/)
[^67]: Combining Elasticsearch with DBs: Real-time Data Synchronization ..., 访问时间为 八月 7, 2025， [https://www.alibabacloud.com/blog/combining-elasticsearch-with-dbs-real-time-data-synchronization_597114](https://www.alibabacloud.com/blog/combining-elasticsearch-with-dbs-real-time-data-synchronization_597114)
[^68]: Multi Model - ArangoDB, 访问时间为 八月 7, 2025， [https://arangodb.com/multi-model/](https://arangodb.com/multi-model/)
[^70]: Advantages of native multi-model in ArangoDB, 访问时间为 八月 7, 2025， [https://arangodb.com/native-multi-model-database-advantages/](https://arangodb.com/native-multi-model-database-advantages/)
[^72]: SQL / AQL - Comparison - ArangoDB, 访问时间为 八月 7, 2025， [https://arangodb.com/sql-aql-comparison/](https://arangodb.com/sql-aql-comparison/)
[^73]: Comparing ArangoDB AQL to Neo4j Cypher, 访问时间为 八月 7, 2025， [https://arangodb.com/learn/graphs/comparing-arangodb-aql-neo4j-cypher/](https://arangodb.com/learn/graphs/comparing-arangodb-aql-neo4j-cypher/)
[^74]: ArangoDB Case Studies | Real-World Success Stories, 访问时间为 八月 7, 2025， [https://arangodb.com/solutions/solutions-customers/](https://arangodb.com/solutions/solutions-customers/)
[^75]: Postgres vs. MongoDB: a Complete Comparison in 2025 - Bytebase, 访问时间为 八月 7, 2025， [https://www.bytebase.com/blog/postgres-vs-mongodb/](https://www.bytebase.com/blog/postgres-vs-mongodb/)
[^77]: Data Modeling - Database Manual - MongoDB Docs, 访问时间为 八月 7, 2025， [https://www.mongodb.com/docs/manual/data-modeling/](https://www.mongodb.com/docs/manual/data-modeling/)
[^79]: MongoDB - Embedded Documents - GeeksforGeeks, 访问时间为 八月 7, 2025， [https://www.geeksforgeeks.org/mongodb/mongodb-embedded-documents/](https://www.geeksforgeeks.org/mongodb/mongodb-embedded-documents/)
[^80]: MongoDB Aggregation: tutorial with examples and exercises ..., 访问时间为 八月 7, 2025， [https://studio3t.com/knowledge-base/articles/mongodb-aggregation-framework/](https://studio3t.com/knowledge-base/articles/mongodb-aggregation-framework/)
[^81]: MongoDB Aggregation Framework: A Beginner's Guide - Foojay.io, 访问时间为 八月 7, 2025， [https://foojay.io/today/mongodb-aggregation-framework-a-beginners-guide/](https://foojay.io/today/mongodb-aggregation-framework-a-beginners-guide/)
